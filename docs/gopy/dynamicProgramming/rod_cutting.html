<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>gopy.dynamicProgramming.rod_cutting API documentation</title>
<meta name="description" content="This module provides two implementations for the rod-cutting problem:
1. A naive recursive implementation which has an exponential runtime
2. Two â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gopy.dynamicProgramming.rod_cutting</code></h1>
</header>
<section id="section-intro">
<p>This module provides two implementations for the rod-cutting problem:
1. A naive recursive implementation which has an exponential runtime
2. Two dynamic programming implementations which have quadratic runtime</p>
<p>The rod-cutting problem is the problem of finding the maximum possible revenue
obtainable from a rod of length <code>n</code> given a list of prices for each integral piece
of the rod. The maximum revenue can thus be obtained by cutting the rod and selling the
pieces separately or not cutting it at all if the price of it is the maximum obtainable.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides two implementations for the rod-cutting problem:
1. A naive recursive implementation which has an exponential runtime
2. Two dynamic programming implementations which have quadratic runtime

The rod-cutting problem is the problem of finding the maximum possible revenue
obtainable from a rod of length ``n`` given a list of prices for each integral piece
of the rod. The maximum revenue can thus be obtained by cutting the rod and selling the
pieces separately or not cutting it at all if the price of it is the maximum obtainable.

&#34;&#34;&#34;


def naive_cut_rod_recursive(n: int, prices: list):
    &#34;&#34;&#34;
        Solves the rod-cutting problem via naively without using the benefit of dynamic programming.
        The results is the same sub-problems are solved several times leading to an exponential runtime

        Runtime: O(2^n)

        Arguments
        -------
        n: int, the length of the rod
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``

        Returns
        -------
        The maximum revenue obtainable for a rod of length n given the list of prices for each piece.

        Examples
        --------
        &gt;&gt;&gt; naive_cut_rod_recursive(4, [1, 5, 8, 9])
        10
        &gt;&gt;&gt; naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
        30
        &#34;&#34;&#34;

    _enforce_args(n, prices)
    if n == 0:
        return 0
    max_revue = float(&#34;-inf&#34;)
    for i in range(1, n + 1):
        max_revue = max(
            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)
        )

    return max_revue


def top_down_cut_rod(n: int, prices: list):
    &#34;&#34;&#34;
        Constructs a top-down dynamic programming solution for the rod-cutting problem
        via memoization. This function serves as a wrapper for _top_down_cut_rod_recursive

        Runtime: O(n^2)

        Arguments
        --------
        n: int, the length of the rod
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``

        Note
        ----
        For convenience and because Python&#39;s lists using 0-indexing, length(max_rev) = n + 1,
        to accommodate for the revenue obtainable from a rod of length 0.

        Returns
        -------
        The maximum revenue obtainable for a rod of length n given the list of prices for each piece.

        Examples
        -------
        &gt;&gt;&gt; top_down_cut_rod(4, [1, 5, 8, 9])
        10
        &gt;&gt;&gt; top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
        30
        &#34;&#34;&#34;
    _enforce_args(n, prices)
    max_rev = [float(&#34;-inf&#34;) for _ in range(n + 1)]
    return _top_down_cut_rod_recursive(n, prices, max_rev)


def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):
    &#34;&#34;&#34;
        Constructs a top-down dynamic programming solution for the rod-cutting problem
        via memoization.

        Runtime: O(n^2)

        Arguments
        --------
        n: int, the length of the rod
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``
        max_rev: list, the computed maximum revenue for a piece of rod.
        ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``

        Returns
        -------
        The maximum revenue obtainable for a rod of length n given the list of prices for each piece.
        &#34;&#34;&#34;
    if max_rev[n] &gt;= 0:
        return max_rev[n]
    elif n == 0:
        return 0
    else:
        max_revenue = float(&#34;-inf&#34;)
        for i in range(1, n + 1):
            max_revenue = max(
                max_revenue,
                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),
            )

        max_rev[n] = max_revenue

    return max_rev[n]


def bottom_up_cut_rod(n: int, prices: list):
    &#34;&#34;&#34;
        Constructs a bottom-up dynamic programming solution for the rod-cutting problem

        Runtime: O(n^2)

        Arguments
        ----------
        n: int, the maximum length of the rod.
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``

        Returns
        -------
        The maximum revenue obtainable from cutting a rod of length n given
        the prices for each piece of rod p.

        Examples
        -------
        &gt;&gt;&gt; bottom_up_cut_rod(4, [1, 5, 8, 9])
        10
        &gt;&gt;&gt; bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
        30
        &#34;&#34;&#34;
    _enforce_args(n, prices)

    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of length 0.
    max_rev = [float(&#34;-inf&#34;) for _ in range(n + 1)]
    max_rev[0] = 0

    for i in range(1, n + 1):
        max_revenue_i = max_rev[i]
        for j in range(1, i + 1):
            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])

        max_rev[i] = max_revenue_i

    return max_rev[n]


def _enforce_args(n: int, prices: list):
    &#34;&#34;&#34;
        Basic checks on the arguments to the rod-cutting algorithms

        n: int, the length of the rod
        prices: list, the price list for each piece of rod.

        Throws ValueError:

        if n is negative or there are fewer items in the price list than the length of the rod
        &#34;&#34;&#34;
    if n &lt; 0:
        raise ValueError(f&#34;n must be greater than or equal to 0. Got n = {n}&#34;)

    if n &gt; len(prices):
        raise ValueError(
            f&#34;Each integral piece of rod must have a corresponding &#34;
            f&#34;price. Got n = {n} but length of prices = {len(prices)}&#34;
        )


def main():
    prices = [6, 10, 12, 15, 20, 23]
    n = len(prices)

    # the best revenue comes from cutting the rod into 6 pieces, each
    # of length 1 resulting in a revenue of 6 * 6 = 36.
    expected_max_revenue = 36

    max_rev_top_down = top_down_cut_rod(n, prices)
    max_rev_bottom_up = bottom_up_cut_rod(n, prices)
    max_rev_naive = naive_cut_rod_recursive(n, prices)

    assert expected_max_revenue == max_rev_top_down
    assert max_rev_top_down == max_rev_bottom_up
    assert max_rev_bottom_up == max_rev_naive


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gopy.dynamicProgramming.rod_cutting.bottom_up_cut_rod"><code class="name flex">
<span>def <span class="ident">bottom_up_cut_rod</span></span>(<span>n, prices)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a bottom-up dynamic programming solution for the rod-cutting problem</p>
<p>Runtime: O(n^2)</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt>n: int, the maximum length of the rod.</dt>
<dt><strong><code>prices</code></strong> :&ensp;<code>list</code>, <code>the</code> <code>prices</code> <code>for</code> <code>each</code> <code>piece</code> of <code>rod.</code> <code>`p`[`i`-`i`]</code> <code>is</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>price for a rod of length <code>i</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>maximum</code> <code>revenue</code> <code>obtainable</code> <code>from</code> <code>cutting</code> <code>a</code> <code>rod</code> of <code>length</code> <code>n</code> <code>given</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>the prices for each piece of rod p.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; bottom_up_cut_rod(4, [1, 5, 8, 9])
**`10`**
</code></pre>
<dl>
<dd>
<p>&nbsp;</p>
<blockquote>
<blockquote>
<blockquote>
<p>bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
<strong><code>30</code></strong></p>
</blockquote>
</blockquote>
</blockquote>
</dd>
<dd>
<p>&nbsp;</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom_up_cut_rod(n: int, prices: list):
    &#34;&#34;&#34;
        Constructs a bottom-up dynamic programming solution for the rod-cutting problem

        Runtime: O(n^2)

        Arguments
        ----------
        n: int, the maximum length of the rod.
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``

        Returns
        -------
        The maximum revenue obtainable from cutting a rod of length n given
        the prices for each piece of rod p.

        Examples
        -------
        &gt;&gt;&gt; bottom_up_cut_rod(4, [1, 5, 8, 9])
        10
        &gt;&gt;&gt; bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
        30
        &#34;&#34;&#34;
    _enforce_args(n, prices)

    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of length 0.
    max_rev = [float(&#34;-inf&#34;) for _ in range(n + 1)]
    max_rev[0] = 0

    for i in range(1, n + 1):
        max_revenue_i = max_rev[i]
        for j in range(1, i + 1):
            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])

        max_rev[i] = max_revenue_i

    return max_rev[n]</code></pre>
</details>
</dd>
<dt id="gopy.dynamicProgramming.rod_cutting.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    prices = [6, 10, 12, 15, 20, 23]
    n = len(prices)

    # the best revenue comes from cutting the rod into 6 pieces, each
    # of length 1 resulting in a revenue of 6 * 6 = 36.
    expected_max_revenue = 36

    max_rev_top_down = top_down_cut_rod(n, prices)
    max_rev_bottom_up = bottom_up_cut_rod(n, prices)
    max_rev_naive = naive_cut_rod_recursive(n, prices)

    assert expected_max_revenue == max_rev_top_down
    assert max_rev_top_down == max_rev_bottom_up
    assert max_rev_bottom_up == max_rev_naive</code></pre>
</details>
</dd>
<dt id="gopy.dynamicProgramming.rod_cutting.naive_cut_rod_recursive"><code class="name flex">
<span>def <span class="ident">naive_cut_rod_recursive</span></span>(<span>n, prices)</span>
</code></dt>
<dd>
<section class="desc"><p>Solves the rod-cutting problem via naively without using the benefit of dynamic programming.
The results is the same sub-problems are solved several times leading to an exponential runtime</p>
<p>Runtime: O(2^n)</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, <code>the</code> <code>length</code> of <code>the</code> <code>rod</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>prices</code></strong> :&ensp;<code>list</code>, <code>the</code> <code>prices</code> <code>for</code> <code>each</code> <code>piece</code> of <code>rod.</code> <code>`p`[`i`-`i`]</code> <code>is</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>price for a rod of length <code>i</code></p>
<h2 id="returns">Returns</h2>
<p>The maximum revenue obtainable for a rod of length n given the list of prices for each piece.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; naive_cut_rod_recursive(4, [1, 5, 8, 9])
**`10`**
</code></pre>
<dl>
<dd>
<p>&nbsp;</p>
<blockquote>
<blockquote>
<blockquote>
<p>naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
<strong><code>30</code></strong></p>
</blockquote>
</blockquote>
</blockquote>
</dd>
<dd>
<p>&nbsp;</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def naive_cut_rod_recursive(n: int, prices: list):
    &#34;&#34;&#34;
        Solves the rod-cutting problem via naively without using the benefit of dynamic programming.
        The results is the same sub-problems are solved several times leading to an exponential runtime

        Runtime: O(2^n)

        Arguments
        -------
        n: int, the length of the rod
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``

        Returns
        -------
        The maximum revenue obtainable for a rod of length n given the list of prices for each piece.

        Examples
        --------
        &gt;&gt;&gt; naive_cut_rod_recursive(4, [1, 5, 8, 9])
        10
        &gt;&gt;&gt; naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
        30
        &#34;&#34;&#34;

    _enforce_args(n, prices)
    if n == 0:
        return 0
    max_revue = float(&#34;-inf&#34;)
    for i in range(1, n + 1):
        max_revue = max(
            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)
        )

    return max_revue</code></pre>
</details>
</dd>
<dt id="gopy.dynamicProgramming.rod_cutting.top_down_cut_rod"><code class="name flex">
<span>def <span class="ident">top_down_cut_rod</span></span>(<span>n, prices)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a top-down dynamic programming solution for the rod-cutting problem
via memoization. This function serves as a wrapper for _top_down_cut_rod_recursive</p>
<p>Runtime: O(n^2)</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, <code>the</code> <code>length</code> of <code>the</code> <code>rod</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>prices</code></strong> :&ensp;<code>list</code>, <code>the</code> <code>prices</code> <code>for</code> <code>each</code> <code>piece</code> of <code>rod.</code> <code>`p`[`i`-`i`]</code> <code>is</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>price for a rod of length <code>i</code></p>
<h2 id="note">Note</h2>
<p>For convenience and because Python's lists using 0-indexing, length(max_rev) = n + 1,
to accommodate for the revenue obtainable from a rod of length 0.</p>
<h2 id="returns">Returns</h2>
<p>The maximum revenue obtainable for a rod of length n given the list of prices for each piece.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; top_down_cut_rod(4, [1, 5, 8, 9])
**`10`**
</code></pre>
<dl>
<dd>
<p>&nbsp;</p>
<blockquote>
<blockquote>
<blockquote>
<p>top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
<strong><code>30</code></strong></p>
</blockquote>
</blockquote>
</blockquote>
</dd>
<dd>
<p>&nbsp;</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top_down_cut_rod(n: int, prices: list):
    &#34;&#34;&#34;
        Constructs a top-down dynamic programming solution for the rod-cutting problem
        via memoization. This function serves as a wrapper for _top_down_cut_rod_recursive

        Runtime: O(n^2)

        Arguments
        --------
        n: int, the length of the rod
        prices: list, the prices for each piece of rod. ``p[i-i]`` is the
        price for a rod of length ``i``

        Note
        ----
        For convenience and because Python&#39;s lists using 0-indexing, length(max_rev) = n + 1,
        to accommodate for the revenue obtainable from a rod of length 0.

        Returns
        -------
        The maximum revenue obtainable for a rod of length n given the list of prices for each piece.

        Examples
        -------
        &gt;&gt;&gt; top_down_cut_rod(4, [1, 5, 8, 9])
        10
        &gt;&gt;&gt; top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
        30
        &#34;&#34;&#34;
    _enforce_args(n, prices)
    max_rev = [float(&#34;-inf&#34;) for _ in range(n + 1)]
    return _top_down_cut_rod_recursive(n, prices, max_rev)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gopy.dynamicProgramming" href="index.html">gopy.dynamicProgramming</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gopy.dynamicProgramming.rod_cutting.bottom_up_cut_rod" href="#gopy.dynamicProgramming.rod_cutting.bottom_up_cut_rod">bottom_up_cut_rod</a></code></li>
<li><code><a title="gopy.dynamicProgramming.rod_cutting.main" href="#gopy.dynamicProgramming.rod_cutting.main">main</a></code></li>
<li><code><a title="gopy.dynamicProgramming.rod_cutting.naive_cut_rod_recursive" href="#gopy.dynamicProgramming.rod_cutting.naive_cut_rod_recursive">naive_cut_rod_recursive</a></code></li>
<li><code><a title="gopy.dynamicProgramming.rod_cutting.top_down_cut_rod" href="#gopy.dynamicProgramming.rod_cutting.top_down_cut_rod">top_down_cut_rod</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>