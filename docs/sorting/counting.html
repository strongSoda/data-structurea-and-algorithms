<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>gopy.sorting.counting API documentation</title>
<meta name="description" content="Counting sort is an efficient algorithm for sorting an array of elements that each have
a nonnegative integer key, for example, an array, sometimes …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gopy.sorting.counting</code></h1>
</header>
<section id="section-intro">
<p>Counting sort is an efficient algorithm for sorting an array of elements that each have
a nonnegative integer key, for example, an array, sometimes called a list, of positive
integers could have keys that are just the value of the integer as the key, or a list
of words could have keys assigned to them by some scheme mapping the alphabet to
integers (to sort in alphabetical order, for instance). Unlike other sorting algorithms,
such as mergesort, counting sort is an integer sorting algorithm, not a comparison based
algorithm. While any comparison based sorting algorithm requires Omega(nlgn)Ω(nlgn)
comparisons, counting sort has a running time of Theta(n)Θ(n) when the length of the
input list is not much smaller than the largest key value, kk, in the list. Counting
sort can be used as a subroutine for other, more powerful, sorting algorithms such as
radix sort</p>
<h3 id="complexity-of-counting-sort">Complexity of Counting Sort</h3>
<p>Counting sort has a O(k+n)O(k+n) running time.</p>
<p>The first loop goes through AA, which has nn elements. This step has a O(n)O(n) running
time. The second loop iterates over kk, so this step has a running time of O(k)O(k). The
third loop iterates through AA, so again, this has a running time of O(n)O(n). Therefore,
the counting sort algorithm has a running time of O(k+n)O(k+n).</p>
<p>Counting sort is efficient if the range of input data, kk, is not significantly greater
than the number of objects to be sorted, nn.</p>
<p>Counting sort is a stable sort with a space complexity of <strong>O(k + n)O(k+n).</strong></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Counting sort is an efficient algorithm for sorting an array of elements that each have 
a nonnegative integer key, for example, an array, sometimes called a list, of positive 
integers could have keys that are just the value of the integer as the key, or a list 
of words could have keys assigned to them by some scheme mapping the alphabet to 
integers (to sort in alphabetical order, for instance). Unlike other sorting algorithms, 
such as mergesort, counting sort is an integer sorting algorithm, not a comparison based 
algorithm. While any comparison based sorting algorithm requires Omega(nlgn)Ω(nlgn) 
comparisons, counting sort has a running time of Theta(n)Θ(n) when the length of the 
input list is not much smaller than the largest key value, kk, in the list. Counting 
sort can be used as a subroutine for other, more powerful, sorting algorithms such as 
radix sort

### Complexity of Counting Sort

Counting sort has a O(k+n)O(k+n) running time.

The first loop goes through AA, which has nn elements. This step has a O(n)O(n) running 
time. The second loop iterates over kk, so this step has a running time of O(k)O(k). The 
third loop iterates through AA, so again, this has a running time of O(n)O(n). Therefore, 
the counting sort algorithm has a running time of O(k+n)O(k+n).

Counting sort is efficient if the range of input data, kk, is not significantly greater 
than the number of objects to be sorted, nn.

Counting sort is a stable sort with a space complexity of **O(k + n)O(k+n).**

&#34;&#34;&#34;
def counting_sort(array, largest):
    c = [0]*(largest + 1)
    for i in range(len(array)):
        c[array[i]] = c[array[i]] + 1
 
    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]
 
    result = [None]*len(array)
 
    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(array):
        result[c[x]] = x
        c[x] = c[x] - 1
 
    return result

def sort(array):
    return counting_sort(array, max(array))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gopy.sorting.counting.counting_sort"><code class="name flex">
<span>def <span class="ident">counting_sort</span></span>(<span>array, largest)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counting_sort(array, largest):
    c = [0]*(largest + 1)
    for i in range(len(array)):
        c[array[i]] = c[array[i]] + 1
 
    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]
 
    result = [None]*len(array)
 
    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(array):
        result[c[x]] = x
        c[x] = c[x] - 1
 
    return result</code></pre>
</details>
</dd>
<dt id="gopy.sorting.counting.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>array)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(array):
    return counting_sort(array, max(array))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#complexity-of-counting-sort">Complexity of Counting Sort</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gopy.sorting" href="index.html">gopy.sorting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gopy.sorting.counting.counting_sort" href="#gopy.sorting.counting.counting_sort">counting_sort</a></code></li>
<li><code><a title="gopy.sorting.counting.sort" href="#gopy.sorting.counting.sort">sort</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>